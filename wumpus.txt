// Hunt the Wumpus implementato in Rust con pattern MVC e macroquad
// Struttura del progetto:
// - Model: gestisce la logica di gioco
// - View: gestisce la rappresentazione grafica
// - Controller: gestisce gli input dell'utente e aggiorna il model

use macroquad::prelude::*;
use std::collections::HashSet;
use rand::{thread_rng, Rng, seq::SliceRandom};

// ----- STATI DI GIOCO -----
#[derive(Debug, Clone, Copy, PartialEq)]
enum GameState {
    Splash,  // Schermata iniziale
    Play,    // Gioco in corso
    Over,    // Fine partita (vittoria o sconfitta)
}

// ----- COSTANTI -----
const NUM_ROOMS: usize = 20;
const NUM_TUNNELS_PER_ROOM: usize = 3;
const NUM_BATS: usize = 2;
const NUM_PITS: usize = 2;
const SCREEN_WIDTH: f32 = 800.0;
const SCREEN_HEIGHT: f32 = 600.0;
const ROOM_RADIUS: f32 = 30.0;

// ----- MODEL -----
struct GameModel {
    // Topologia della caverna (grafo)
    tunnels: Vec<Vec<usize>>,
    // Posizioni degli elementi del gioco
    player_position: usize,
    wumpus_position: usize,
    bat_positions: HashSet<usize>,  
    pit_positions: HashSet<usize>,
    // Stato del gioco
    game_over: bool,
    win: bool,
    has_arrow: bool,
    message: String,
    // Coordinate visive delle stanze
    room_positions: Vec<Vec2>,
    // Statistiche di gioco
    moves_count: u32,
    start_time: f64,
    end_time: f64,
}

impl GameModel {
    fn new() -> Self {
        let tunnels = GameModel::create_cave_topology();
        let room_positions = GameModel::calculate_room_positions();
        let mut model = GameModel {
            tunnels,
            player_position: 0,
            wumpus_position: 0,
            bat_positions: HashSet::new(),
            pit_positions: HashSet::new(),
            game_over: false,
            win: false,
            has_arrow: true,
            message: String::from("Benvenuto a Hunt the Wumpus! Usa le frecce per muoverti, spazio per tirare una freccia."),
            room_positions,
            moves_count: 0,
            start_time: 0.0,
            end_time: 0.0,
        };
        model.initialize_game();
        model
    }

    fn create_cave_topology() -> Vec<Vec<usize>> {
        // Implementazione del dodecaedro standard per Hunt the Wumpus
        // In alternativa si potrebbe generare un grafo casuale
        vec![
            vec![1, 4, 5],    // 0
            vec![0, 2, 7],    // 1
            vec![1, 3, 9],    // 2
            vec![2, 4, 11],   // 3
            vec![0, 3, 13],   // 4
            vec![0, 6, 14],   // 5
            vec![5, 7, 15],   // 6
            vec![1, 6, 8],    // 7
            vec![7, 9, 16],   // 8
            vec![2, 8, 10],   // 9
            vec![9, 11, 17],  // 10
            vec![3, 10, 12],  // 11
            vec![11, 13, 18], // 12
            vec![4, 12, 14],  // 13
            vec![5, 13, 19],  // 14
            vec![6, 16, 19],  // 15
            vec![8, 15, 17],  // 16
            vec![10, 16, 18], // 17
            vec![12, 17, 19], // 18
            vec![14, 15, 18], // 19
        ]
    }

    fn calculate_room_positions() -> Vec<Vec2> {
        // Calcola le posizioni delle stanze in un cerchio
        let mut positions = Vec::with_capacity(NUM_ROOMS);
        let center_x = SCREEN_WIDTH / 2.0;
        let center_y = SCREEN_HEIGHT / 2.0;
        let radius = SCREEN_HEIGHT * 0.4;

        // Posizioni esterne (0-11)
        for i in 0..12 {
            let angle = i as f32 * std::f32::consts::PI * 2.0 / 12.0;
            positions.push(Vec2::new(
                center_x + radius * angle.cos(),
                center_y + radius * angle.sin(),
            ));
        }

        // Posizioni interne (12-19)
        let inner_radius = radius * 0.5;
        for i in 0..8 {
            let angle = i as f32 * std::f32::consts::PI * 2.0 / 8.0 + std::f32::consts::PI / 8.0;
            positions.push(Vec2::new(
                center_x + inner_radius * angle.cos(),
                center_y + inner_radius * angle.sin(),
            ));
        }

        positions
    }

    fn initialize_game(&mut self) {
        let mut rng = thread_rng();
        let mut available_rooms: Vec<usize> = (0..NUM_ROOMS).collect();
        available_rooms.shuffle(&mut rng);

        // Posiziona il giocatore
        self.player_position = available_rooms.pop().unwrap();

        // Posiziona il Wumpus
        self.wumpus_position = available_rooms.pop().unwrap();

        // Posiziona i pipistrelli
        self.bat_positions.clear();
        for _ in 0..NUM_BATS {
            self.bat_positions.insert(available_rooms.pop().unwrap());
        }

        // Posiziona le fosse
        self.pit_positions.clear();
        for _ in 0..NUM_PITS {
            self.pit_positions.insert(available_rooms.pop().unwrap());
        }

        self.game_over = false;
        self.win = false;
        self.has_arrow = true;
        self.message = String::from("Benvenuto a Hunt the Wumpus! Usa le frecce per muoverti, spazio per tirare una freccia.");
        self.moves_count = 0;
        self.start_time = get_time();
        self.end_time = 0.0;
    }

 stanza con pipistrelli
            return self.move_player(self.player_position);
        }
        
        // Genera gli avvertimenti
        self.generate_warnings();
        
        return true;
    }

    fn generate_warnings(&mut self) {
        let mut warnings = Vec::new();
        
        // Controlla se il Wumpus è vicino
        if self.tunnels[self.player_position].contains(&self.wumpus_position) {
            warnings.push("Senti un fetore nauseabondo...");
        }
        
        // Controlla se ci sono fosse vicine
        for &tunnel in &self.tunnels[self.player_position] {
            if self.pit_positions.contains(&tunnel) {
                warnings.push("Senti una brezza leggera...");
                break;
            }
        }
        
        // Controlla se ci sono pipistrelli vicini
        for &tunnel in &self.tunnels[self.player_position] {
            if self.bat_positions.contains(&tunnel) {
                warnings.push("Senti uno squittio in lontananza...");
                break;
            }
        }
        
        if warnings.is_empty() {
            self.message = format!("Ti trovi nella stanza {}. Tutto sembra tranquillo.", self.player_position);
        } else {
            self.message = format!("Ti trovi nella stanza {}. {}", self.player_position, warnings.join(" "));
        }
    }

    fn shoot_arrow(&mut self, target_room: usize) {
        if !self.has_arrow {
            self.message = String::from("Non hai più frecce!");
            return;
        }
        
        // Verifica se la stanza è collegata alla posizione attuale
        if !self.tunnels[self.player_position].contains(&target_room) {
            self.message = format!("Non puoi tirare la freccia alla stanza {}!", target_room);
            return;
        }
        
        self.has_arrow = false;
        
        if target_room == self.wumpus_position {
            self.message = String::from("Hai colpito il Wumpus! Hai vinto!");
            self.game_over = true;
            self.win = true;
            self.end_time = get_time();
        } else {
            self.message = format!("Hai mancato! La freccia è andata nella stanza {}.", target_room);
            
            // Il Wumpus potrebbe spostarsi
            let mut rng = thread_rng();
            if rng.gen::<f32>() < 0.75 {  // 75% di probabilità che il Wumpus si sposti
                let wumpus_tunnels = &self.tunnels[self.wumpus_position];
                let new_wumpus_pos = *wumpus_tunnels.choose(&mut rng).unwrap();
                
                if new_wumpus_pos == self.player_position {
                    self.message = String::from("Il Wumpus si è svegliato e ti ha trovato! Game Over!");
                    self.game_over = true;
                    self.end_time = get_time();
                } else {
                    self.wumpus_position = new_wumpus_pos;
                    self.message += " Il Wumpus si è svegliato e si è spostato!";
                }
            }
        }
    }

    fn reset(&mut self) {
        self.initialize_game();
    }
}

// ----- VIEW -----
struct GameView {
    font_size: f32,
    title_font_size: f32,
}

impl GameView {
    fn new() -> Self {
        GameView {
            font_size: 20.0,
            title_font_size: 40.0,
        }
    }

    async fn load_resources(&self) {
        // Qui potremmo caricare immagini o altri asset
    }

    fn draw_splash(&self) {
        clear_background(BLACK);
        
        // Titolo del gioco
        let title = "HUNT THE WUMPUS";
        let title_size = measure_text(title, None, self.title_font_size as u16, 1.0);
        draw_text(
            title,
            SCREEN_WIDTH/2.0 - title_size.width/2.0,
            SCREEN_HEIGHT/3.0,
            self.title_font_size,
            GOLD
        );
        
        // Sottotitolo
        let subtitle = "Un classico gioco di avventura";
        let subtitle_size = measure_text(subtitle, None, (self.font_size * 1.2) as u16, 1.0);
        draw_text(
            subtitle,
            SCREEN_WIDTH/2.0 - subtitle_size.width/2.0,
            SCREEN_HEIGHT/3.0 + 50.0,
            self.font_size * 1.2,
            WHITE
        );
        
        // Istruzioni
        let instructions = [
            "Esplora le stanze della caverna e caccia il temibile Wumpus.",
            "Attenzione alle fosse e ai pipistrelli giganti!",
            "Usa il mouse per muoverti tra le stanze.",
            "Premi SPAZIO per attivare la modalità di tiro con l'arco.",
            "",
            "Premi SPAZIO o clicca per iniziare"
        ];
        
        for (i, line) in instructions.iter().enumerate() {
            let line_size = measure_text(line, None, self.font_size as u16, 1.0);
            draw_text(
                line,
                SCREEN_WIDTH/2.0 - line_size.width/2.0,
                SCREEN_HEIGHT/2.0 + (i as f32 * 30.0),
                self.font_size,
                LIGHTGRAY
            );
        }
        
        // Animazione "Premi per iniziare"
        let blink_rate = ((get_time() * 2.0) as f32).sin() * 0.5 + 0.5;
        let press_start = "Premi SPAZIO o clicca per iniziare";
        let press_start_size = measure_text(press_start, None, self.font_size as u16, 1.0);
        draw_text(
            press_start,
            SCREEN_WIDTH/2.0 - press_start_size.width/2.0,
            SCREEN_HEIGHT - 100.0,
            self.font_size,
            Color::new(1.0, 1.0, 1.0, blink_rate)
        );
    }

    fn draw_game(&self, model: &GameModel) {
        clear_background(BLACK);
        
        // Disegna le connessioni tra le stanze (tunnel)
        for (from, tunnels) in model.tunnels.iter().enumerate() {
            let from_pos = model.room_positions[from];
            for &to in tunnels {
                let to_pos = model.room_positions[to];
                draw_line(from_pos.x, from_pos.y, to_pos.x, to_pos.y, 2.0, DARKGRAY);
            }
        }
        
        // Disegna le stanze
        for (i, pos) in model.room_positions.iter().enumerate() {
            let color = if i == model.player_position {
                GREEN
            } else {
                GRAY
            };
            
            draw_circle(pos.x, pos.y, ROOM_RADIUS, color);
            draw_text(&i.to_string(), pos.x - 10.0, pos.y + 8.0, self.font_size, WHITE);
        }
        
        // Disegna l'interfaccia utente
        let message_width = measure_text(&model.message, None, self.font_size as u16, 1.0).width;
        draw_text(&model.message, SCREEN_WIDTH/2.0 - message_width/2.0, SCREEN_HEIGHT - 50.0, self.font_size, WHITE);
        
        // Disegna lo stato della freccia
        let arrow_text = if model.has_arrow { "Freccia: ✓" } else { "Freccia: ✗" };
        draw_text(arrow_text, 20.0, 30.0, self.font_size, WHITE);
        
        // Disegna i comandi disponibili
        draw_text("Usa il mouse per muoverti o tirare frecce", 20.0, SCREEN_HEIGHT - 20.0, self.font_size - 5.0, LIGHTGRAY);
    }

    fn draw_game_over(&self, model: &GameModel, transition_timer: f32) {
        // Prima disegna il gioco per mostrare lo stato finale
        self.draw_game(model);
        
        // Poi sovrapponi il messaggio di game over con un effetto di fade-in
        let alpha = f32::min(transition_timer, 1.0);
        
        // Disegna il Wumpus nella sua posizione
        let wumpus_pos = model.room_positions[model.wumpus_position];
        draw_circle(wumpus_pos.x, wumpus_pos.y, ROOM_RADIUS, RED);
        
        // Rettangolo semi-trasparente per il messaggio
        draw_rectangle(
            0.0,
            SCREEN_HEIGHT/2.0 - 150.0,
            SCREEN_WIDTH,
            300.0,
            Color::new(0.0, 0.0, 0.0, 0.8 * alpha)
        );
        
        // Messaggio di vittoria o sconfitta
        let end_message = if model.win {
            "Hai vinto! Hai eliminato il Wumpus!"
        } else {
            "Game Over! Il Wumpus ti ha preso!"
        };
        
        let text_size = measure_text(end_message, None, (self.title_font_size * 0.8) as u16, 1.0);
        draw_text(
            end_message,
            SCREEN_WIDTH/2.0 - text_size.width/2.0,
            SCREEN_HEIGHT/2.0 - 50.0,
            self.title_font_size * 0.8,
            if model.win { GREEN } else { RED }
        );
        
        // Mostra statistiche di gioco
        let game_time = model.end_time - model.start_time;
        let stats_message = format!("Mosse: {} | Tempo: {:.1} secondi", 
                                   model.moves_count,
                                   game_time);
        
        let stats_size = measure_text(&stats_message, None, self.font_size as u16, 1.0);
        draw_text(
            &stats_message,
            SCREEN_WIDTH/2.0 - stats_size.width/2.0,
            SCREEN_HEIGHT/2.0,
            self.font_size,
            WHITE
        );
        
        // Istruzioni per ricominciare
        let restart_text = "Premi R per ricominciare o ESC per tornare al menu";
        let restart_size = measure_text(restart_text, None, self.font_size as u16, 1.0);
        draw_text(
            restart_text,
            SCREEN_WIDTH/2.0 - restart_size.width/2.0,
            SCREEN_HEIGHT/2.0 + 50.0,
            self.font_size,
            WHITE
        );
    }

    fn get_clicked_room(&self, model: &GameModel, mouse_pos: Vec2) -> Option<usize> {
        for (i, pos) in model.room_positions.iter().enumerate() {
            if (mouse_pos - *pos).length() <= ROOM_RADIUS {
                return Some(i);
            }
        }
        None
    }
}

// ----- CONTROLLER -----
struct GameController {
    shoot_mode: bool,
    selected_room: Option<usize>,
    view: GameView,  // Riferimento alla view per riutilizzare get_clicked_room
}

impl GameController {
    fn new() -> Self {
        GameController {
            shoot_mode: false,
            selected_room: None,
            view: GameView::new(),
        }
    }

    fn process_input(&mut self, model: &mut GameModel) {
        // Cambia modalità (movimento o tiro)
        if is_key_pressed(KeyCode::Space) {
            if model.has_arrow {
                self.shoot_mode = !self.shoot_mode;
                if self.shoot_mode {
                    model.message = String::from("Modalità tiro attivata. Clicca su una stanza adiacente per tirare la freccia.");
                } else {
                    model.message = String::from("Modalità movimento attivata.");
                    model.generate_warnings();
                }
            } else {
                model.message = String::from("Non hai più frecce!");
            }
        }
        
        // Gestione del click del mouse
        if is_mouse_button_pressed(MouseButton::Left) {
            let mouse_pos = Vec2::new(mouse_position().0, mouse_position().1);
            if let Some(room) = self.view.get_clicked_room(model, mouse_pos) {
                if self.shoot_mode {
                    model.shoot_arrow(room);
                    self.shoot_mode = false;
                } else {
                    model.move_player(room);
                }
            }
        }
        
        // Evidenzia la stanza sotto il cursore
        let mouse_pos = Vec2::new(mouse_position().0, mouse_position().1);
        self.selected_room = self.view.get_clicked_room(model, mouse_pos);
    }
    
    fn process_splash_input(&self) -> bool {
        // Ritorna true se l'utente vuole passare allo stato di gioco
        is_key_pressed(KeyCode::Space) || is_mouse_button_pressed(MouseButton::Left)
    }
    
    fn process_game_over_input(&self) -> (bool, bool) {
        // Ritorna (ricomincia, torna_al_menu)
        let restart = is_key_pressed(KeyCode::R);
        let to_menu = is_key_pressed(KeyCode::Escape);
        (restart, to_menu)
    }
}

// ----- GAME STATE -----
struct Game {
    state: GameState,
    model: GameModel,
    view: GameView,
    controller: GameController,
    splash_timer: f32,
    transition_timer: f32,
}

impl Game {
    fn new() -> Self {
        Game {
            state: GameState::Splash,
            model: GameModel::new(),
            view: GameView::new(),
            controller: GameController::new(),
            splash_timer: 0.0,
            transition_timer: 0.0,
        }
    }

    async fn initialize(&mut self) {
        self.view.load_resources().await;
    }

    fn update(&mut self) {
        match self.state {
            GameState::Splash => self.update_splash(),
            GameState::Play => self.update_play(),
            GameState::Over => self.update_over(),
        }
    }

    fn update_splash(&mut self) {
        // Aggiorna il timer della schermata di splash
        self.splash_timer += get_frame_time();
        
        // Passa allo stato di gioco se viene premuto un tasto o passa abbastanza tempo
        if is_key_pressed(KeyCode::Space) || is_mouse_button_pressed(MouseButton::Left) || self.splash_timer > 3.0 {
            self.state = GameState::Play;
        }
    }

    fn update_play(&mut self) {
        // Aggiorna il controller e il modello durante il gioco
        self.controller.process_input(&mut self.model);
        
        // Se il gioco è finito, passa allo stato "Over"
        if self.model.game_over {
            self.state = GameState::Over;
            self.transition_timer = 0.0;
        }
    }

    fn update_over(&mut self) {
        // Aggiorna il timer per la schermata di game over
        self.transition_timer += get_frame_time();
        
        // Permetti di ricominciare premendo R
        if is_key_pressed(KeyCode::R) {
            self.model.reset();
            self.state = GameState::Play;
        }
        
        // Permetti di tornare alla schermata iniziale premendo Esc
        if is_key_pressed(KeyCode::Escape) {
            self.model.reset();
            self.state = GameState::Splash;
            self.splash_timer = 0.0;
        }
    }

    fn draw(&self) {
        match self.state {
            GameState::Splash => self.view.draw_splash(),
            GameState::Play => self.view.draw_game(&self.model),
            GameState::Over => self.view.draw_game_over(&self.model, self.transition_timer),
        }
    }
}

// ----- MAIN -----
#[macroquad::main("Hunt the Wumpus")]
async fn main() {
    let mut game = Game::new();
    game.initialize().await;
    
    loop {
        // Aggiornamento e disegno gestiti attraverso i diversi stati
        game.update();
        game.draw();
        
        next_frame().await;
    }
}